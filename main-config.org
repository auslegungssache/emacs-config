#+TITLE: aeggy's emacs config
#+AUTHOR: aeggy

TODO: use use-package :bind instead of (global-set-key)
TODO: use use-package :hook instead of (add-hook)
TODO: use use-package :custom instead of (setq), or make an alternative (:set)
TODO: untangle without loading org
TODO: add uniquify
* Package management
** Straight
*** TODO Load
This contains legacy code; fix it.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src
** use-package
Load use-package and make it install all packages by default
#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

  (use-package diminish)
#+end_src
* Behavior
** TODO Path
Inherit PATH from the shell
** Initial buffer
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t) ; don't show the info startup screen
  (setq inhibit-startup-message t) ; ... and the message
  (setq initial-scratch-message nil) ; remove all text from the scratch buffer
  (defun display-startup-echo-area-message ()
    (message "Welcome."))
  (setq inhibit-startup-message t)
  (setq initial-major-mode 'org-mode) ; create scratch buffer with org mode
#+end_src
** Startup
Resume the previous session
#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src
** Loading
Automatically revert a buffer when it changes on disk
#+begin_src emacs-lisp
  (global-auto-revert-mode 0)
#+end_src
** TODO Scrolling
Smoother scrolling
#+begin_src emacs-lisp
  (setq scroll-margin 10)
  (setq scroll-step 1)
  (setq scroll-conservatively 100000)
  (setq next-line-add-newlines nil)
  (setq scroll-preserve-screen-position t)
#+end_src
*** Mouse
#+begin_src emacs-lisp
  (setq mouse-wheel-follow-mouse t) ; scroll buffer over which the mouse is
  (setq mouse-wheel-scroll-amount '(1
                                    ((shift)
                                     . hscroll)
                                    ((meta))
                                    ((control)
                                     . text-scale))) ; add various modifiers to scrolling
#+end_src
** Indent guides
Show lines that highlight the indentation levels
#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :config
    (setq highlight-indent-guides-method 'character
          highlight-indent-guides-auto-enabled nil)
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+end_src
** Backups
Put all backups in a single directory
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory))))
#+end_src
** Quitting
TODO: add support for quitting any minibuffer dialogue with ESC
** Dialogs
Make all prompts y-or-n
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Saving
Clean up the whitespace when saving
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src
** Recent
#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src
** Text replacing
Replace selection when you start typing
#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src
** Echoing status
*** Keystrokes
#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1) ; show keystrokes right away
#+end_src
** Parenthesis highlighting
TODO: extend this to all kinds of blocks
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src
** Prettify symbols
TODO: add more characters
TODO: add ligatures
#+begin_src emacs-lisp
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (setq inhibit-compacting-font-caches t)
  (add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+end_src
** TODO Undo
Add support for undo-tree with evil integration
** Tooltips
#+begin_src emacs-lisp
  (setq x-gtk-use-system-tooltips nil)
#+end_src
** GUI
#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t) ; make emacs frames maximize fully
#+end_src
** Cursor highlighting
#+begin_src emacs-lisp
  (blink-cursor-mode 0) ; disable cursor blinking
  (use-package beacon
    :config
    (beacon-mode t)) ; show cursor when it jumps
#+end_src
** expand-region
#+begin_src emacs-lisp
(use-package expand-region
  :config
  (global-set-key (kbd "C-=") #'er/expand-region))
#+end_src
** TODO smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :config
  (require 'smartparens-config)
  (smartparens-global-mode t))
#+end_src
** Fix annoying keys
*** Audio keys
These keys get captured in Xorg with WSL
#+begin_src emacs-lisp
(global-set-key (kbd "<XF86AudioLowerVolume>") #'ignore)
(global-set-key (kbd "<XF86AudioRaiseVolume>") #'ignore)
(global-set-key (kbd "<XF86AudioMute>") #'ignore)
#+end_src
* TODO Spelling and text autocompletion
** Ispell
#+begin_src emacs-lisp
(use-package ispell
  :straight nil)
#+end_src
** Flyspell
TODO: disable when changing modes to a programming mode
#+begin_src emacs-lisp :tangle no
(use-package flyspell
  :straight nil
  :config
  (add-hook 'prog-mode-hook flyspell-mode))
#+end_src
Use flyspell
** TODO Autocompletion of words
** TODO Automatic checking and fixing
** TODO Automatic selecting of language
* Help
** Help buffer
Automatically select the help buffer, so that it'd be easier to close after reading
#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src
** TODO Helpful
#+begin_src emacs-lisp
  (use-package helpful)
#+end_src
* Buffer / window navigation
** Ibuffer
Ibuffer provides a dired-like interface for working with buffers
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src
** Windmove
Allow navigating windows with Shift-<key arrow>
#+begin_src emacs-lisp
  (windmove-default-keybindings)
#+end_src
** Eyebrowse
Adds workspaces
#+begin_src emacs-lisp
  (use-package eyebrowse
    :config
    (eyebrowse-mode 1))
#+end_src
** ace-window
Manipulate windows with ace
#+begin_src emacs-lisp
  (use-package ace-window
    :config
    (global-set-key (kbd "M-o") 'ace-window)
    (global-set-key (kbd "C-c w") 'ace-window))
#+end_src
** winner
#+begin_src emacs-lisp
  (use-package winner
    :straight nil
    :config
    (winner-mode t))
#+end_src
** TODO Ediff
#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (setq ediff-split-window-function 'split-window-horizontally))
#+end_src
* Project navigation
** TODO counsel-rg
** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :diminish
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (projectile-mode 1))
#+end_src
* Completion
** Selectrum
#+begin_src emacs-lisp
  (use-package selectrum
    :config
    (global-set-key (kbd "C-c ,") #'selectrum-quick-select) ;; add avy-like selection by key annotations
    (global-set-key (kbd "C-c r") #'selectrum-repeat)
    (bind-key "<escape>" #'abort-recursive-edit selectrum-minibuffer-map)
    (set-face-attribute 'selectrum-current-candidate nil :foreground "#68f3ca")
    (selectrum-mode t))
#+end_src
*** TODO Fix the theme
*** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode t))
#+end_src
*** Prescient
#+begin_src emacs-lisp
  (use-package prescient
    :config
    (prescient-persist-mode t))
  (use-package selectrum-prescient
    :config
    (selectrum-prescient-mode t))
#+end_src
** Consult
#+begin_src emacs-lisp
(use-package consult
  :bind (("C-x b" . consult-buffer)
         ("C-c m" . consult-imenu)
         ("C-x M-:" . consult-complex-command)))
(use-package consult-dir
  :bind (("C-c d" . #'consult-dir)))
(use-package consult-company
  :after (consult company))
(use-package consult-flycheck)
#+end_src
* Embark
#+begin_src emacs-lisp
(use-package embark
  :config
  (global-set-key (kbd "C-c .") #'embark-act)
  (global-set-key (kbd "C-h B") #'embark-bindings))
(use-package embark-consult
  :after (embark consult))
#+end_src
* Aesthetics
** Font
Use system font
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :height 100)
#+end_src
** Colorscheme
#+begin_src emacs-lisp
(use-package kaolin-themes
  :config
  (load-theme 'kaolin-galaxy t))
#+end_src
** Editor frame
Make Emacs more minimalist
#+begin_src emacs-lisp
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
#+end_src

Add some widgets
#+begin_src emacs-lisp
  ;;(global-hl-line-mode 1)
  (column-number-mode 1)
  (size-indication-mode 1)
#+end_src
** Fringe
*** Size
#+begin_src emacs-lisp
  (set-fringe-mode 8)
#+end_src
*** EOF
#+begin_src emacs-lisp
  (setq-default indicate-empty-lines t)
#+end_src
*** TODO git gutter
** Frame title
#+begin_src emacs-lisp
  (setq-default frame-title-format "%b (%f)") ; add a bit better frame title
#+end_src
** Bell
#+begin_src emacs-lisp
  (setq ring-bell-function (lambda ()))
  (setq visible-bell nil)
#+end_src
** Line numbers
#+begin_src emacs-lisp
  (setq-default display-line-numbers-type 'relative)
  (global-display-line-numbers-mode 1)
#+end_src
** Modeline
*** clock
#+begin_src emacs-lisp
  (use-package display-time
    :no-require t
    :straight nil
    :init
    (setq display-time-24hr-format t)
    (setq display-time-day-and-date t)
    (setq display-time-default-load-average nil)
    :config
    (display-time-mode t))
#+end_src
* Org
TODO: fix speed commands
TODO: configure maintaining the ~/org/ directory
TODO: uncomment and test org-log logging
#+begin_src emacs-lisp
;; (setq org-use-speed-commands t)
(setq org-startup-indented t)
;; (setq org-log-into-drawer t)
;; (setq org-log-done 'time)
(setq org-support-shift-select t)
;; (setq org-directory "~/org/")
;; (setq org-agenda-files '("~/org/"))
#+end_src
** Evil
#+begin_src emacs-lisp
  ;; TODO: add make blocks cycleable from evil normal mode
#+end_src
** Babel
#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t)
(setq org-src-preserve-indentation nil)
(setq org-src-window-setup 'current-window)
#+end_src
*** Source blocks
#+begin_src emacs-lisp
  (setq org-structure-template-alist ())
  (add-to-list 'org-structure-template-alist '("e" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("s" . "src sh"))
#+end_src
*** Exporting
**** HTML
Allow exporting to HTML
#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src
* Evil
#+begin_src emacs-lisp
  (use-package evil
    :config
    (evil-mode t))
#+end_src
* Dired
** Narrowing
#+begin_src emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
                (")" . #'dired-narrow)))
#+end_src
** Omit
#+begin_src emacs-lisp
  (use-package dired-x
    :straight nil
    :bind (:map dired-mode-map
                ("O" . #'dired-omit-mode))
    :config
    (setq dired-omit-files "^\\...+$")
    (add-hook 'dired-mode-hook #'dired-omit-mode))
#+end_src
** DWIM
#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src
** Details
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (use-package dired-collapse
    :config
    (add-hook 'dired-mode-hook #'dired-collapse-mode))
  (use-package dired-subtree
    :bind (:map dired-mode-map
                (("i" . 'dired-subtree-insert)
                 ("I" . 'dired-subtree-remove))))
#+end_src
** Interacting with the outside
#+begin_src emacs-lisp
  (setq dired-auto-revert-buffer t)
#+end_src
* Terminal
** Vterm
#+begin_src emacs-lisp
  (use-package vterm
    :when (eq system-type 'gnu/linux)
    :config
    (setq-default vterm-exit-functions #'kill-buffer)
    (setq vterm-kill-buffer-on-exit t)
    (evil-set-initial-state 'vterm-mode 'emacs)

    (add-hook 'vterm-mode-hook (lambda ()
                                 (display-line-numbers-mode 0))))
#+end_src
*** eshell-vterm
#+begin_src emacs-lisp
  (use-package eshell-vterm
    :config
    (eshell-vterm-mode)
    (defalias 'eshell/v 'eshell-exec-visual))
#+end_src
**** TODO [#A] Fix error when exiting buffer
** Eshell
#+begin_src emacs-lisp
  (require 'eshell)
#+end_src
*** Decoration
#+begin_src emacs-lisp
  (add-hook 'eshell-mode-hook (lambda () (display-line-numbers-mode 0)))
#+end_src
*** Completion
#+begin_src emacs-lisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "<tab>") #'completion-at-point)
              (define-key eshell-mode-map (kbd "C-M-i") #'completion-at-point)))
#+end_src
*** Clear
Clear the eshell buffer
#+begin_src emacs-lisp
  (defun eshell/nuke ()
    "Clear the eshell buffer."
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)
      (delete-region 1 2)))

  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "M-l") #'eshell/nuke)))
#+end_src
*** Last
Go to the last line of the window
#+begin_src emacs-lisp
  (defun eshell/last ()
    "Clear the window"
    (interactive)
    (goto-char (point-max))
    (recenter 0))

  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "C-l") #'eshell/last)))
#+end_src
*** TODO Backspace
Pressing backspace on an empty prompt should send the user to the previous prompt
#+begin_src emacs-lisp :tangle no
  (defun eshell--backspace ()
    (interactive)
    (if (get-char-property (- (point) 1) 'read-only)
        (eshell-previous-prompt 1)
      (backward-delete-char-untabify 'untabify)))

  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "DEL") #'eshell--backspace)
              (define-key eshell-mode-map (kbd "<M-left>") #'eshell-previous-prompt)
              (define-key eshell-mode-map (kbd "<M-right>") #'eshell-next-prompt)))
#+end_src
*** M-x
Run emacs commands from eshell
#+begin_src emacs-lisp
  (defun eshell/run (&optional command)
    (if command
        (call-interactively (intern command))
      (error "No command")))
#+end_src
*** C-d
#+begin_src emacs-lisp
  (defun eshell-C-d () (interactive) (if (eq (point) (point-max)) (eshell-life-is-too-much) (delete-char 1)))
  (add-hook 'eshell-mode-hook (lambda () (local-set-key (kbd "C-d") 'eshell-C-d)))
#+end_src
*** View
View a file in a read-only window with syntax highlighting
**** TODO Kill buffer and window after pressing q
#+begin_src emacs-lisp
  (defun eshell/view (filename)
    (let ((opened (get-file-buffer filename))))
    (with-current-buffer (find-file-noselect filename)
      (view-mode)
      (switch-to-buffer-other-window (current-buffer))
      (local-set-key (kbd "q") #'kill-buffer-and-window)
      ()))
#+end_src
* Programming
** Lisp
*** Sly
#+begin_src emacs-lisp
  (setq inferior-lisp-program "sbcl")
  (use-package sly
    :config
    (add-hook 'sly-db-hook #'evil-emacs-state))
#+end_src
** Universal
*** Indentation
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)

  (use-package aggressive-indent
    :config
    (global-aggressive-indent-mode 1))
#+end_src
*** Parenthesis
#+begin_src emacs-lisp
  (electric-pair-mode 1)
  (show-paren-mode 1)
#+end_src
*** Completion
#+begin_src emacs-lisp
  (use-package company
    :config
    (setq company-dabbrev-downcase 0)
    (setq company-idle-delay 0)
    (global-set-key (kbd "M-SPC") #'company-complete)
    (add-hook 'prog-mode-hook #'company-mode))
  (use-package company-prescient
    :config
    (company-prescient-mode t))
#+end_src
**** TODO Use counsel-company
*** Error checking
TODO: Fix for elisp
#+begin_src emacs-lisp
  (use-package flycheck
    :init
    :config
    (global-flycheck-mode 0)
    (setq-default flycheck-disabled-checkers '(emacs-list-checkdoc)))
#+end_src
** Go
#+begin_src emacs-lisp
  (use-package go-mode
    :config
    (add-hook 'before-save-hook 'gofmt-before-save))
  (use-package company-go
    :after company)
#+end_src
** Web
*** TypeScript
#+begin_src emacs-lisp
  (use-package tide
    :init
    (setq typescript-indent-level 4)
    :config
    (add-hook 'typescript-mode-hook (lambda () (tide-mode 1))))
#+end_src
* Git
TODO: add magit-forge
#+begin_src emacs-lisp
  (use-package magit
    :config
    (global-set-key (kbd "C-x g") 'magit-status))
#+end_src
** git gutter
TODO: fix showing modified lines
#+begin_src emacs-lisp
  (use-package git-gutter
    :diminish
    :config
    (global-git-gutter-mode t)
    (set-face-background 'git-gutter:modified 'nil)
    (set-face-foreground 'git-gutter:added "green4")
    (set-face-foreground 'git-gutter:deleted "red"))
#+end_src
* Text editing
** TODO multiple-cursors
Add it and make it compatible with Evil
** Olivetti
TODO: make it wider
TODO: disable line numbers
#+begin_src emacs-lisp
  (use-package olivetti)
#+end_src
** avy
#+begin_src emacs-lisp
  (use-package avy
    :config
    (global-set-key (kbd "C-:") 'avy-goto-char-timer))
#+end_src
** ace-link
#+begin_src emacs-lisp
  (use-package ace-link
    :config
    (global-set-key (kbd "C-c l") #'ace-link))
#+end_src
** move-text
#+begin_src emacs-lisp
  (use-package move-text
    :config
    (move-text-default-bindings))
#+end_src
** TODO snippets
#+begin_src emacs-lisp
  (use-package yasnippet)
#+end_src
* Web services
** Pastebins
Easy access to pastebins
#+begin_src emacs-lisp
  (use-package webpaste)
#+end_src
* Hydras
** Install
#+begin_src emacs-lisp
  (use-package hydra)
#+end_src
** Scripts
No hydras yet
* Useful tools
** TODO Crux
#+begin_src emacs-lisp
  (use-package crux)
#+end_src
** Devdocs
TODO: consider using devdocs-browser instead
#+begin_src emacs-lisp
  (use-package devdocs)
#+end_src
** Playground
#+begin_src emacs-lisp
  ;; TODO: add a playground minor mode with various features like in smalltalk's playground

  (defvar playground-default-name "playground"
    "Name that will be used for a playground buffer, if no name is
  specified in the function call.")
  (defvar playground-default-separator ":"
    "Character(s) that will be used adding an index to a playground buffer name.")
  (defvar playground-reuse-playgrounds nil
    "Non-nil if playgrounds should reuse names of closed playgrouds, otherwise a counter of previously opened playgrounds will be used.")
  (defvar playground--count 0
    "Count of playgrounds that have already been opened.")

  (defun playground-uniquify-name (name &optional separator)
    (when (not separator)
      (setq separator playground-default-separator))
    (if playground-reuse-playgrounds
        (progn
          (let ((i 1)
                (buffer-name))
            (while (get-buffer (setq buffer-name (concat name separator (number-to-string i))))
              (setq i (1+ i)))
            buffer-name))
      (let ((buffer-name (concat name separator (number-to-string playground--count))))
        (if (get-buffer buffer-name)
            (playground-uniquify-name name (concat separator separator))
          (setq playground--count (1+ playground--count))
          buffer-name))))

  (defun playground (&optional name)
    (interactive)

    (when (not name)
      (setq name playground-default-name))
    (let* ((buffer-name (playground-uniquify-name name))
           (buffer (get-buffer-create buffer-name)))
      (with-current-buffer buffer (emacs-lisp-mode))
      (pop-to-buffer buffer)))
#+end_src
