#+TITLE: aeggy's emacs config
#+AUTHOR: aeggy

* Package management
** Straight
*** Load
This is a copypasted install script.
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq straight-vc-git-default-clone-depth 1)
  ;; A full history (in the case of editing the code) can be fetched
  ;; with M-x magit-remote-unshallow

  (setq straight-check-for-modifications nil)
#+end_src
*** repo finder
#+begin_src emacs-lisp
  (defun my-straight-get-repo (package insert)
    "Echo repo to the inputted package if it exists."
    (interactive
     (list
      (intern
       (completing-read "Package: "
                        (straight-recipes-list)
                        (lambda (_) t)
                        'require-match))
      current-prefix-arg))


    (let ((recipe (cdr (straight-recipes-retrieve package)))
          (url))
      (if (eq (plist-get recipe :host) 'github)
          (progn
            (setq url (concat "https://github.com/" (plist-get recipe :repo)))
            (message url)
            (when insert (insert url)))
        (message "not hosted on github"))))
#+end_src
** use-package
Load use-package and make it install all packages by default
#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (use-package use-package
    :demand
    :config
    (setq straight-use-package-by-default t)

    (defun wrap-in-use-package ()
      (interactive)
      (let ((substring (buffer-substring (region-beginning) (region-end))))
        (setf (buffer-substring (region-beginning) (region-end))
              (format "(use-package emacs\n:config\n%s)" (s-trim substring))))))

  (use-package diminish)
#+end_src
** Leaf
#+begin_src emacs-lisp
  (straight-use-package 'leaf)
  (straight-use-package 'leaf-keywords)
  (leaf leaf
    :require t)
  (leaf leaf-keywords
    :require t
    :config
    (leaf-keywords-init))
#+end_src
* Garbage collection
#+begin_src emacs-lisp
  (leaf gcmh
    :straight t
    :require t
    :config
    (gcmh-mode t))
#+end_src
* no-littering
#+begin_src emacs-lisp
  (leaf no-littering
    :straight t
    :require t
    :config
    (setq auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-save/")
                                            t)))
    (setq custom-file (no-littering-expand-etc-file-name "custom.el")))
#+end_src
* Behavior
** General.el
#+begin_src emacs-lisp
  (leaf general
    :straight t
    :require t
    :config
    (general-auto-unbind-keys)
    (general-create-definer leader-def :states 'normal :prefix "SPC")
    (leader-def "SPC" #'execute-extended-command))
#+end_src
** Libraries
#+begin_src emacs-lisp
  (leaf s
    :straight t
    :require t)

  (leaf f
    :straight t
    :require t)

  (leaf dash
    :straight t
    :require t)
#+end_src
** Path
Inherit PATH from the shell
#+begin_src emacs-lisp
  (leaf exec-path-from-shell
    :straight t
    :require t
    :config
    (exec-path-from-shell-initialize))
#+end_src
** Initial buffer
#+begin_src emacs-lisp
  (leaf inhibit
    :preface
    (defun display-startup-echo-area-message ()
      (message "Welcome."))

    :setq ((inhibit-startup-screen . t)
           (inhibit-startup-message . t)
           (initial-scratch-message . nil)
           (initial-major-mode function org-mode)))
#+end_src
** Loading
Automatically revert a buffer when it changes on disk
#+begin_src emacs-lisp
  (leaf autorevert
    :require t
    :config
    (global-auto-revert-mode 0))
#+end_src
** TODO Scrolling
Smoother scrolling
#+begin_src emacs-lisp
  (leaf good-scroll
    :straight t
    :require t
    :config
    (good-scroll-mode t))
  ;; TODO: Fix weird jumping
#+end_src
*** Mouse
#+begin_src emacs-lisp
  (leaf mouse-color
    :config
    (add-hook 'after-init-hook
              (lambda ()
                (set-mouse-color "white"))))
#+end_src
** Indent guides
Show lines that highlight the indentation levels
#+begin_src emacs-lisp
  (leaf highlight-indent-guides
    :hook (prog-mode-hook)
    :straight t
    :require t
    :setq ((highlight-indent-guides-method quote character)
           (highlight-indent-guides-auto-enabled))
    :config
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray"))
#+end_src
** Quitting
TODO: add support for quitting any minibuffer dialogue with ESC
** Dialogs
Make all prompts y-or-n
#+begin_src emacs-lisp
  (leaf y-or-n
    :config
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src
** Saving
#+begin_src emacs-lisp
  (leaf autosave
    :setq ((auto-save-no-message . t)))
#+end_src
** Saving
Clean up the whitespace when saving
#+begin_src emacs-lisp
  (leaf whitespace
    :hook ((before-save-hook . whitespace-cleanup))
    :require t)
#+end_src
** Recent
#+begin_src emacs-lisp
  (leaf recentf
    :require t
    :config
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory)
    (recentf-mode 1))
#+end_src
** Text replacing
Replace selection when you start typing
#+begin_src emacs-lisp
  (leaf delsel
    :config
    (delete-selection-mode t))
#+end_src
** Echoing status
*** Keystrokes
#+begin_src emacs-lisp
  (leaf echo-keys
    :setq ((echo-keystrokes . 0.1)))
#+end_src
** Parenthesis highlighting
#+begin_src emacs-lisp
  (leaf rainbow-delimiters
    :hook (prog-mode-hook)
    :straight t
    :require t)
#+end_src
** Prettify symbols
TODO: add more characters
TODO: add ligatures
#+begin_src emacs-lisp
  (leaf prettify-symbols
    :hook ((prog-mode-hook . prettify-symbols-mode))
    :setq ((prettify-symbols-unprettify-at-point quote right-edge)
           (inhibit-compacting-font-caches . t)))
#+end_src
** Undo
#+begin_src emacs-lisp
  (leaf vundo
    :straight t
    :require t
    :bind ("C-x u" . #'vundo))
#+end_src
** Tooltips
#+begin_src emacs-lisp
  (leaf gtk
    :setq ((x-gtk-use-system-tooltips)))
#+end_src
** GUI
#+begin_src emacs-lisp
  (leaf frame-resize
    :setq ((frame-resize-pixelwise . t)))
#+end_src
** Jump highlighting
Alternative to beacon
#+begin_src emacs-lisp
  (leaf pulse
    :preface
    (defun pulse-line (&rest _)
      "Pulse the current line."
      (pulse-momentary-highlight-one-line
       (point)))

    :require t
    :config
    (set-face-background 'pulse-highlight-start-face "yellow")
    (dolist (command
             '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
      (advice-add command :after #'pulse-line)))
#+end_src
** expand-region
#+begin_src emacs-lisp
  (leaf expand-region
    :bind (("C-=" . er/expand-region))
    :straight t
    :require t)
#+end_src
** TODO smartparens
#+begin_src emacs-lisp
  (leaf smartparens
    :require t smartparens-config
    :straight t
    :config
    (smartparens-global-mode t))
#+end_src
** Fix annoying keys
*** Audio keys
These keys get captured in Xorg with WSL
#+begin_src emacs-lisp
  (leaf audio-keys
    :bind (("<XF86AudioLowerVolume>" . ignore)
           ("<XF86AudioRaiseVolume>" . ignore)
           ("<XF86AudioMute>" . ignore)))
#+end_src
** read-only
#+begin_src emacs-lisp
  (leaf read-only
    :setq ((view-read-only . t)))
#+end_src
** upcase / downcase / capitalize
#+begin_src emacs-lisp
  (leaf cases
    :bind (("M-u" . upcase-dwim)
           ("M-l" . downcase-dwim)
           ("M-c" . capitalize-dwim)))
#+end_src
** Uniquify
#+begin_src emacs-lisp
  (leaf uniquify
    :require t
    :setq ((uniquify-buffer-name-style quote forward)
           (uniquify-separator . "/")
           (uniquify-after-kill-buffer-p . t)
           (uniquify-ignore-buffers-re . "^\\*")))
#+end_src
** Icons
#+begin_src emacs-lisp
  (leaf all-the-icons
    :straight t
    :require t)
#+end_src
*** Completion
#+begin_src emacs-lisp
  (leaf all-the-icons-completion
    :straight t
    :require t
    :config
    (all-the-icons-completion-mode t))
#+end_src
*** Ibuffer
#+begin_src emacs-lisp
  (leaf all-the-icons-ibuffer
    :straight t
    :require t
    :hook (ibuffer-mode-hook . all-the-icons-ibuffer-mode))
#+end_src
*** TODO Add icons to more files
** TODO WSL
#+begin_src emacs-lisp
  (defvar wsl-user)

  (defun wsl-p nil
    (not (eq
          (or
           (string-match-p "Windows"
                           (getenv "PATH"))
           (string-match-p "Microsoft"
                           (shell-command-to-string "uname -a")))
          nil)))

  (defun wsl-insert-home nil
    (interactive)
    (if (wsl-p)
        (insert
         (format "/mnt/c/Users/%s/" wsl-user))
      (message "you're not on wsl")))

  (defun explorer-current-dir ()
    (interactive)

    (shell-command (format "explorer.exe .") nil nil))

  (when (wsl-p)
    (defun wsl-hostname nil
      "Get the hostname of the host os."
      (interactive)
      (let ((hostname (s-trim
                       (shell-command-to-string "grep -m 1 nameserver /etc/resolv.conf | awk '{print $2}'"))))
        (message "Address is %s" hostname)
        (kill-new hostname))))
  (when (wsl-p)
    (setq wsl-user (string-trim-right
                    (shell-command-to-string "powershell.exe '$env:UserName'"))))
  (when (wsl-p)
    (setq browse-url-browser-function #'browse-url-generic
          browse-url-generic-program "explorer.exe"))
  (when (wsl-p)
    (global-set-key
     (kbd "<Scroll_Lock>")
     #'ignore))
#+end_src
*** TODO explorer.exe sometimes opens incorrectly
** TODO Emotes
Add emojify https://github.com/iqbalansari/emacs-emojify
** TODO Search engines
#+begin_src emacs-lisp
  (leaf engine-mode
    :straight t
    :require t
    :setq ((engine/browser-function function browse-url-xdg-open))
    :config
    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s" :keybinding "g")
    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s" :keybinding "d")
    (defengine google
      "https://google.com/search?q=%s" :keybinding "g")
    (engine/set-keymap-prefix
     (kbd "C-c e")))
#+end_src
*** TODO Make it use the browser outside of WSL
* TODO Spelling and text autocompletion
** Ispell
#+begin_src emacs-lisp
  (leaf ispell)
#+end_src
** Flyspell
TODO: disable when changing modes to a programming mode
#+begin_src emacs-lisp :tangle no
  (use-package flyspell
    :straight nil
    :hook prog-mode)
#+end_src
Use flyspell
** TODO Autocompletion of words
** TODO Automatic checking and fixing
** TODO Automatic selecting of language
* Emacs development
** TODO Refine
Broken
#+begin_src emacs-lisp :tangle no
  (use-package refine
    :config
    (add-hook 'refine-mode-hook #'evil-emacs-state))
#+end_src
* Mule
#+begin_src emacs-lisp
  (leaf mule
    :require t
    :config
    (leader-def
      "m m" #'set-input-method
      "m t" #'toggle-input-method
      "m i" #'describe-input-method
      "m e" (lambda ()
              (interactive)
              (set-input-method "emoji"))))
#+end_src
* Help
** Show keys
#+begin_src emacs-lisp :tangle no
  (leaf which-key
    :straight t
    :require t
    :setq ((which-key-idle-delay . 0.5))
    :config
    (which-key-mode))
#+end_src
** TODO Shortdoc
=shortdoc-display-group=
** Help buffer
Automatically select the help buffer, so that it'd be easier to close after reading
#+begin_src emacs-lisp
  (leaf help
    :setq ((help-window-select . t)))
#+end_src
** TODO Helpful
#+begin_src emacs-lisp
  (leaf helpful
    :straight t
    :require t)
#+end_src
** Function discovery
#+begin_src emacs-lisp
  (leaf suggest
    :straight t
    :require t)
#+end_src
** TODO Info
#+begin_src emacs-lisp
  (leaf info
    :bind ((Info-mode-map
            ("C-c l" . ace-link)))
    :require t)
#+end_src
* C
** TODO Uncrustify
Disabled because it needs the uncrustify binary
#+begin_src emacs-lisp
  (use-package uncrustify
    :disabled t)
#+end_src
* Compiling
** RMSBolt
#+begin_src emacs-lisp
  (leaf rmsbolt
    :straight t)
#+end_src
* explain-pause-mode
#+begin_src emacs-lisp
  (use-package explain-pause-mode
    :disabled
    :config
    (explain-pause-mode t))
#+end_src
* Reading
** PDF
#+begin_src emacs-lisp
  (use-package pdf-tools ;; This package causes issues
    :defer
    :magic ("%PDF" . (lambda () (pdf-view-mode) (display-line-numbers-mode 0)))
    :config
    (add-hook 'pdf-tools-enabled-hook 'auto-revert-mode))
#+end_src
** Books
#+begin_src emacs-lisp
  (leaf nov
    :mode ("\\.epub\\'")
    :straight t)
#+end_src
* Buffer / window navigation
** Ibuffer
Ibuffer provides a dired-like interface for working with buffers
#+begin_src emacs-lisp
  (leaf ibuffer
    :bind (("C-x C-b" . ibuffer))
    :require t)
#+end_src
** Windmove
Allow navigating windows with Shift-<key arrow>
#+begin_src emacs-lisp
  (leaf windmove
    :require t
    :config
    (windmove-default-keybindings))
#+end_src
** Eyebrowse
Adds workspaces
#+begin_src emacs-lisp
  (leaf eyebrowse
    :init
    (straight-use-package 'eyebrowse)
    :require t
    :config
    (eyebrowse-mode 1))
#+end_src
** ace-window
Manipulate windows with ace
#+begin_src emacs-lisp
  (leaf ace-window
    :bind (("M-o" . ace-window)
           ("C-c w" . ace-window))
    :straight t
    :config
    (leader-def "w" #'ace-window))
#+end_src
** winner
#+begin_src emacs-lisp
  (leaf winner
    :require t
    :config
    (winner-mode t))
#+end_src
** zoom
Automatically resize windows
#+begin_src emacs-lisp
  (leaf zoom
    :straight t
    :require t
    :config
    (leader-def "z" #'zoom))
#+end_src
** TODO Ediff
#+begin_src emacs-lisp
  (leaf ediff
    :require t
    :setq ((ediff-window-setup-function quote ediff-setup-windows-plain)
           (ediff-split-window-function quote split-window-horizontally)))
#+end_src
* Project navigation
** TODO counsel-rg
** Projectile
#+begin_src emacs-lisp
  (leaf projectile
    :bind ((projectile-mode-map
            ("C-c p" . projectile-command-map)))
    :straight t
    :require t
    :diminish projectile-mode
    :setq ((projectile-enable-caching))
    :config
    (leader-def
      "p p" #'projectile-commander
      "p f" #'projectile-find-file
      "p s" #'projectile-switch-project)
    (projectile-global-mode t))
#+end_src
*** TODO Remove projectile
Projectile doesn't behave properly and it should be replaced with
something simpler
* Completion
** Mini frame
#+begin_src emacs-lisp
  (leaf mini-frame
    :straight t
    :require t)
#+end_src
** Recursive
#+begin_src emacs-lisp
  (leaf recursive-minibuffer
    :setq ((enable-recursive-minibuffers . t)
           (minibuffer-depth-indicate-mode . t)))
#+end_src
** Selectrum
#+begin_src emacs-lisp
  (leaf orderless
    :straight t
    :require t)

  (leaf selectrum
    :bind (("C-c r" . selectrum-repeat)
           (selectrum-minibuffer-map
            ("C-c ," . selectrum-quick-select)
            ("<escape>" . abort-recursive-edit)))
    :custom-face ((selectrum-current-candidate '((t
                                                  (:foreground "#68f3ca")))))
    :after orderless
    :straight t
    :require t
    :setq ((completion-styles quote (orderless)))
    :config
    (selectrum-mode t))

  (leaf selectrum-prescient
    :straight t
    :require t
    :setq ((selectrum-prescient-enable-filtering))
    :config
    (selectrum-prescient-mode t)
    (prescient-persist-mode t))
#+end_src
*** TODO Make functions like find-file work like in Ivy (backspaces goes to parent)
*** Marginalia
#+begin_src emacs-lisp
  (leaf marginalia
    :straight t
    :require t
    :config
    (marginalia-mode t))
#+end_src
** Consult
#+begin_src emacs-lisp
  (leaf consult
    :bind (("C-x b" . consult-buffer)
           ("C-c m" . consult-imenu)
           ("C-c s" . consult-line)
           ("C-x M-:" . consult-complex-command))
    :straight t
    :config
    (leader-def "s" #'consult-line))

  (leaf consult-dir
    :straight t
    :require t
    :config
    (leader-def
      "d" #'consult-dir
      "D" #'dired
      "f" #'find-file))

  (leaf consult-flycheck
    :straight t
    :require t)
#+end_src
** At point
#+begin_src emacs-lisp
  (use-package corfu
    :straight (corfu :includes (corfu-quick corfu-info)
                     :files (:defaults "extensions/corfu-*.el"))

    :bind
    (:map corfu-map
          ("M-m" . corfu-move-to-minibuffer)
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))
    :config
    (setq tab-always-indent 'complete)

    (setq corfu-cycle t)
    (setq corfu-count 14)

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    (global-corfu-mode 1))

  (use-package corfu-quick
    :straight nil
    :bind
    (:map corfu-map
          ("C-," . corfu-quick-complete)))

  (use-package corfu-doc
    :config
    (corfu-doc-mode t))

  (use-package corfu-info
    :straight nil
    :bind
    (:map corfu-map
          ("M--" . corfu-info-documentation)
          ("M-p" . corfu-doc-scroll-down)
          ("M-n" . corfu-doc-scroll-up)
          ("M-d" . corfu-doc-toggle)))

#+end_src
* Embark
#+begin_src emacs-lisp
  (leaf embark
    :straight t
    :require t
    :setq ((prefix-help-command function embark-prefix-help-command))
    :config
    (general-def :keymaps
      '(global emacs normal emacs)
      "C-c ." #'embark-act "M-." #'embark-act "C-h B" #'embark-bindings)
    (leader-def "." #'embark-act))

  (leaf embark-consult
    :after (consult embark)
    :straight t
    :require t)
#+end_src
** TODO Relearn
* Aesthetics
** Font
Use system font
#+begin_src emacs-lisp
  (leaf font
    :config
    (set-face-attribute 'default nil
                        :family "Fira Code"
                        :height 120))
#+end_src
** Colorscheme
#+begin_src emacs-lisp
  ;;; Good themes:
  ;; kaolin-themes
  ;; gruvbox-theme

  (leaf doom-themes
    :straight t
    :require t
    :config
    (load-theme 'doom-one t))
#+end_src
** Solaire
Color popout modes differently

#+begin_src emacs-lisp
  (leaf solaire-mode
    :straight t
    :require t
    :config
    (solaire-global-mode t))
#+end_src
** Editor frame
[[file:early-init.el::;; Make emacs more minimalist][Most is stored in the early-init.el file]]
Make Emacs more minimalist

Add some widgets
#+begin_src emacs-lisp
  (leaf decoration
    :config
    (column-number-mode 1)
    (size-indication-mode 1))
#+end_src
** Fringe
*** EOF
#+begin_src emacs-lisp
  (leaf empty-lines
    :setq-default ((indicate-empty-lines . t)))
#+end_src
** Frame title
#+begin_src emacs-lisp
  (leaf frame-title
    :setq-default ((frame-title-format . "%b (%f)")))
#+end_src
** Bell
#+begin_src emacs-lisp
  (leaf bell
    :setq ((visible-bell))
    :config
    (setq ring-bell-function (lambda ())))
#+end_src
** Line numbers
#+begin_src emacs-lisp
  (leaf display-line-numbers
    :hook ((prog-mode-hook . display-line-numbers-mode))
    :require t
    :setq-default ((display-line-numbers-type quote relative)))
#+end_src
** Save place
#+begin_src emacs-lisp
  (leaf saveplace
    :require t
    :config
    (save-place-mode t))
#+end_src
** Modeline
Use doom-modeline for more functionality
#+begin_src emacs-lisp
  (leaf doom-modeline
    :pre-setq ((doom-modeline-indent-info . t))
    :straight t
    :require t
    :config
    (doom-modeline-mode t))
#+end_src
*** Clock
#+begin_src emacs-lisp
  (leaf time
    :require t
    :setq ((display-time-24hr-format . t)
           (display-time-day-and-date . t)
           (display-time-default-load-average))
    :config
    (display-time-mode t))
#+end_src
*** Modeline hiding
#+begin_src emacs-lisp
  (leaf hide-mode-line
    :straight t
    :require t)
#+end_src
* Org
TODO: fix speed commands
TODO: configure maintaining the ~/org/ directory
TODO: uncomment and test org-log logging
#+begin_src emacs-lisp
  (leaf org
    :setq ((org-use-speed-commands . t)
           (org-startup-indented . t)
           (org-support-shift-select . t)
           (org-catch-invisible-edits 'show-and-error)
           (org-hide-emphasis-markers)))

  ;; (setq org-log-into-drawer t)
  ;; (setq org-log-done 'time)
  ;; (setq org-directory "~/org/")
  ;; (setq org-agenda-files '("~/org/"))
#+end_src
** Capture
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline org-default-notes-file "Tasks")
           "* TODO %?\nCreated on: %T%i\n")
          ("r" "Reading list" entry (file+headline org-default-notes-file "Reading list")
           "* TODO %?\nCreated on: %T%i\n")
          ("b" "Book list" entry (file+headline org-default-notes-file "Book list")
           "* TODO %?\nCreated on: %T%i\n")
          ("e" "Emacs todo" entry (file+headline org-default-notes-file "Emacs todo list")
           "* TODO %?\nCreated on: %T%i\n")

          ("f" "Favorite page" entry (file+headline org-default-favorites-file "Favorite pages")
           "* %?\nCreated on: %T%i\n")))
#+end_src
** Keys
#+begin_src emacs-lisp
  (leader-def
    "o b d" (lambda () (interactive) (dired org-directory))
    "o b n" (lambda () (interactive) (find-file org-default-notes-file))
    "o c" #'org-capture
    "o n" #'org-toggle-narrow-to-subtree)
#+end_src
** Evil
#+begin_src emacs-lisp
  ;; TODO: add make blocks cycleable from evil normal mode
  (leaf evil-org
    :after evil org
    :hook (org-mode-hook)
    :straight t
    :require t)
#+end_src
** Babel
#+begin_src emacs-lisp
  (leaf org-src
    :after org
    :require t
    :setq ((org-src-tab-acts-natively . t)
           (org-src-preserve-indentation)
           (org-src-window-setup quote current-window)))
#+end_src
*** Source blocks
#+begin_src emacs-lisp
  (setq org-structure-template-alist ())
  (add-to-list 'org-structure-template-alist '("e" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("s" . "src sh"))
#+end_src
* Pandoc
#+begin_src emacs-lisp
  (leaf pandoc-mode
    :straight t
    :require t
    :config
    (add-hook 'org-mode-hook #'pandoc-mode))
#+end_src
* Evil
#+begin_src emacs-lisp
  (leaf evil
    :hook ((view-mode-hook . evil-motion-state))
    :straight t
    :require t
    :config
    (evil-mode t)
    (evil-define-key
      '(normal visual)
      'global
      (kbd "<tab>")
      #'er/expand-region))
#+end_src
** Lispy
#+begin_src emacs-lisp
  (leaf evil-lispy
    :hook (emacs-lisp-mode-hook clojure-mode-hook)
    :straight t)
#+end_src
* Dired
#+begin_src emacs-lisp
  (leaf dired
    :require t
    :setq ((dired-dwim-target . t)))
#+end_src
** Omit
#+begin_src emacs-lisp
  (leaf dired-x
    :require t
    :setq ((dired-omit-files . "^\\...+$"))
    :config
    (add-to-list 'dired-omit-extensions ".eld"))
#+end_src
* Treemacs
#+begin_src emacs-lisp
  (leaf treemacs
    :after t
    :straight t
    :require t
    :config
    (leader-def "t" #'treemacs-select-window))

  (leaf treemacs-evil
    :after treemacs evil
    :straight t
    :require t)

  (leaf treemacs-projectile
    :after treemacs projectile
    :straight t
    :require t)

  (leaf treemacs-magit
    :after treemacs magit
    :straight t
    :require t)

  (leaf treemacs-all-the-icons
    :after treemacs all-the-icons
    :straight t
    :require t
    :config
    (treemacs-load-theme 'all-the-icons))

  (leaf lsp-treemacs
    :after treemacs lsp-mode
    :straight t
    :require t)
#+end_src
* Tabs
#+begin_src emacs-lisp
  (leaf centaur-tabs
    :straight t
    :require t
    :setq ((centaur-tabs-style . "slant")
           (centaur-tabs-height . 32)
           (centaur-tabs-set-icons . t)
           (centaur-tabs-show-navigation-buttons . t)
           (x-underline-at-descent-line . t)
           (centaur-tabs-set-bar quote under)
           (centaur-tabs-cycle-scope quote tabs)
           (centaur-tabs-enable-ido-completion)
           (centaur-tabs-modified-marker . "●")
           (centaur-tabs-set-modified-marker . t)
           (centaur-tabs-down-tab-text . " ▼ ")
           (centaur-tabs-forward-tab-text . " ▶ ")
           (centaur-tabs-backward-tab-text . " ◀ ")
           (uniquify-separator . "/"))
    :config
    (leader-def "g t s" 'centaur-tabs-switch-group)
    (centaur-tabs-headline-match)
    (centaur-tabs-group-by-projectile-project)
    (centaur-tabs-mode t)
    (general-def :states '(normal)
      "g t" 'centaur-tabs-forward "g T" 'centaur-tabs-backward :package 'centaur-tabs))
#+end_src
* Dirvish
#+begin_src emacs-lisp
  (leaf dirvish
    :straight t
    :require t
    :bind ((dirvish-mode-map
            ("J" . #'dired-goto-file)
            ("j" . #'dired-next-line)
            ("k" . #'dired-previous-line)
            ("<left>" . #'dired-up-directory)
            ("<right>" . #'dired-find-file)))
    :hook (((dirvish-mode-hook dirvish-peek-mode-hook) . centaur-tabs-local-mode)
           (dirvish-mode-hook . (lambda () (toggle-truncate-lines t))))
    :setq ((dirvish-attributes quote (vc-state subtree-state all-the-icons collapse git-msg file-size))
           (dired-listing-switches . "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group"))
    :config
    (evil-set-initial-state 'dirvish-mode 'emacs)
    (dirvish-override-dired-mode)
    (dirvish-peek-mode))
#+end_src
** TODO No centaur-tabs in dirvish-peek
* Terminal
** Vterm
#+begin_src emacs-lisp
  (use-package vterm
    :when (eq system-type 'gnu/linux)
    :defer
    :config
    (setq-default vterm-exit-functions #'kill-buffer)
    (setq vterm-kill-buffer-on-exit t)
    (evil-set-initial-state 'vterm-mode 'emacs)
    (leader-def "v" #'vterm))
#+end_src
*** eshell-vterm
#+begin_src emacs-lisp
  (use-package eshell-vterm
    :after vterm eshell
    :config
    (eshell-vterm-mode)
    (defalias 'eshell/v 'eshell-exec-visual))
#+end_src
**** TODO [#A] Fix error when exiting buffer
** Eshell
#+begin_src emacs-lisp
  (leaf eshell
    :after t
    :setq ((eshell-scroll-to-bottom-on-input . t)
           (eshell-banner-message . ""))
    :config
    (leader-def "e" #'eshell))

  (defun eshell-current-p ()
    (eq major-mode 'eshell-mode))

  (defvar eshell-binds ()
    "Contains pairs of keys and functions")

  (defun eshell-bind-initialize ()
    (dolist (bind eshell-binds)
      (define-key eshell-mode-map (kbd (car bind)) (cadr bind)))
    nil)

  (defun eshell-bind (key function)
    (add-to-list 'eshell-binds (list key function))
    (when (eq major-mode 'eshell-mode)
      (eshell-bind-initialize))
    nil)

  (add-hook 'eshell-mode-hook #'eshell-bind-initialize)

  (eshell-bind "<tab>" #'completion-at-point)
  (eshell-bind "C-M-i" #'completion-at-point)
#+end_src
*** Up
#+begin_src emacs-lisp
  (leaf eshell-up
    :straight t
    :require t
    :config
    (defalias 'eshell/up #'eshell-up))
#+end_src
*** Clear
Clear the eshell buffer
#+begin_src emacs-lisp
  (defun eshell/nuke ()
    "Clear the eshell buffer."
    (interactive)
    (when (eshell-current-p)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)
        (delete-region 1 2))))

  (eshell-bind "M-l" #'eshell/nuke)
#+end_src
*** Last
Go to the last line of the window
#+begin_src emacs-lisp
  (defun eshell/last ()
    "Clear the window"
    (interactive)
    (goto-char (point-max))
    (deactivate-mark)
    (recenter 0))

  (eshell-bind "C-l" #'eshell/last)
#+end_src
*** WSL
**** Home
#+begin_src emacs-lisp
  (defun eshell/wsl-h ()
    (interactive)

    (eshell/cd (concat "/mnt/c/Users/" wsl-user)))
#+end_src
**** C
#+begin_src emacs-lisp
  (defun eshell/wsl-c ()
    (interactive)

    (eshell/cd "/mnt/c/"))
#+end_src
*** TODO img
This shows an extra shell prompt
#+begin_src emacs-lisp
  (defun eshell/img (img-path)
    (let* ((path (expand-file-name img-path))
           (img (create-image path))
           (inhibit-read-only t))
      (setf (image-property img :max-width) (/ (window-pixel-height) 3))
      (let ((current-point (point))
            (map (make-sparse-keymap)))
        (define-key map [mouse-1]
          `(lambda ()
             (interactive)
             (find-file ,path)
             (view-mode)))
        (insert-image img)
        (put-text-property current-point (+ current-point 1)
                           'keymap map))
      (eshell-send-input)
      (delete-region (line-beginning-position) (line-end-position)))
    nil)
#+end_src
*** TODO Backspace
Pressing backspace on an empty prompt should send the user to the previous prompt
#+begin_src emacs-lisp
  (defun eshell--backspace ()
    (interactive)
    (if (get-char-property (- (point) 1) 'read-only)
        (eshell-previous-prompt 1)
      (backward-delete-char 1)))

  (eshell-bind "DEL" #'eshell--backspace)

  (eshell-bind "M-<left>" #'eshell-previous-prompt)
  (eshell-bind "M-<up>" #'eshell-previous-prompt)

  (eshell-bind "M-<right>" #'eshell-next-prompt)
  (eshell-bind "M-<down>" #'eshell-next-prompt)
#+end_src
*** Escape
**** M-x
Run emacs commands from eshell
#+begin_src emacs-lisp
  (defun eshell/in-em (&optional command)
    (if command
        (call-interactively (intern command))
      (error "No command")))
#+end_src
**** Bash
Run in bash
#+begin_src emacs-lisp
  (defun eshell/in-sh (&rest body)
    (let ((command (s-join " " body))
          (inhibit-read-only t))
      (fundamental-mode)
      (call-process "/bin/sh" nil t nil "-c" command)
      (eshell-mode)
      (delete-region (line-beginning-position) (line-end-position))))
#+end_src
*** C-d
Exits if C-d pressed on empty prompt
#+begin_src emacs-lisp
  (defun eshell-C-d ()
    (interactive)
    (if (eq (point) (point-max))
        (eshell-life-is-too-much)
      (delete-char 1)))

  (add-hook 'eshell-mode-hook (lambda () (local-set-key (kbd "C-d") 'eshell-C-d)))
#+end_src
**** TODO Fix this
*** View
View a file in a read-only window with syntax highlighting
#+begin_src emacs-lisp
  (defun eshell/view (filename)
    (let ((opened (get-file-buffer filename))))
    (with-current-buffer (find-file-noselect filename)
      (view-mode)
      (switch-to-buffer-other-window (current-buffer))
      (local-set-key (kbd "q") #'kill-buffer-and-window)
      nil))
#+end_src
*** Visual cd
#+begin_src emacs-lisp
  (defun eshell/vcd ()
    "Visually cd."

    (eshell/cd (read-directory-name "Cd to: ")))
#+end_src
* Programming
** LSP
#+begin_src emacs-lisp
  (leaf lsp-mode
    :commands lsp
    :hook (prog-mode-hook python-mode-hook typescript-mode-hook web-mode-hook)
    :straight t
    :config
    (setq lsp-keymap-prefix "C-c l")
    (define-key lsp-mode-map
                (kbd "C-c l")
                lsp-command-map))

  (leaf lsp-ui
    :after lsp-mode
    :straight t
    :require t
    :setq ((lsp-headerline-breadcrumb-enable)))
#+end_src
** Tree Sitter
#+begin_src emacs-lisp
  (leaf tree-sitter
    :hook ((tree-sitter-after-on-hook . tree-sitter-hl-mode))
    :straight t
    :require t
    :config
    (global-tree-sitter-mode))

  (leaf tree-sitter-langs
    :after tree-sitter
    :straight t
    :require t)
#+end_src
** Web
#+begin_src emacs-lisp
  (leaf web-mode
    :mode ("\\.html" "\\.svelte")
    :straight t
    :config
    (setq web-mode-markup-indent-offset 4)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 4)
    (setq web-mode-part-padding 4)
    (setq web-mode-block-padding 4)
    (setq web-mode-style-padding 2)
    (setq web-mode-script-padding 4)
    (setq web-mode-enable-auto-pairing t))
#+end_src
** Typescript
#+begin_src emacs-lisp
  (leaf typescript-mode
    :mode ("\\.ts$" "\\.tsx$")
    :straight t)
#+end_src
** Clojure
#+begin_src emacs-lisp
  (leaf cider
    :mode ("\\.clj$" "\\.cljs$")
    :straight t
    :config
    (evil-set-initial-state 'cider-inspector-mode 'emacs))
#+end_src
** Common Lisp
*** Sly
#+begin_src emacs-lisp
  (setq inferior-lisp-program "sbcl")
  (leaf sly
    :mode ("\\.cl$" "\\.lisp$")
    :straight t
    :config
    (add-hook 'sly-db-hook #'evil-emacs-state))
#+end_src
** Universal
*** Indentation
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)

  (leaf aggressive-indent
    :straight t
    :require t
    :config
    (global-aggressive-indent-mode 1))
#+end_src
*** Parenthesis
#+begin_src emacs-lisp
  (leaf paren
    :config
    (electric-pair-mode 1)
    (show-paren-mode 1))
#+end_src
*** TODO Flycheck
TODO: Fix for elisp
#+begin_src emacs-lisp
  (leaf flycheck
    :straight t
    :require t
    :setq-default ((flycheck-disabled-checkers quote
                                               (emacs-list-checkdoc)))
    :config
    (global-flycheck-mode 0))
#+end_src
*** TODO Quickrun
#+begin_src emacs-lisp
  (leaf quickrun
    :straight t)
#+end_src
* Git
#+begin_src emacs-lisp
  (leaf magit
    :after t
    :bind (("C-x g" . magit-status))
    :straight t
    :require t)

  (leaf forge
    :after magit
    :straight t
    :require t)
#+end_src
** git gutter
#+begin_src emacs-lisp
  (leaf git-gutter
    :pre-setq ((git-gutter:hide-gutter . t)
               (git-gutter:verbosity . 0)
               (git-gutter:update-interval . 0.02))
    :straight t
    :require t
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode t))

  (leaf fringe-helper
    :straight t
    :require t)

  (leaf git-gutter-fringe
    :after git-gutter fringe-helper
    :straight t
    :require t
    :diminish git-gutter-fringe-mode
    :config
    (fringe-helper-define 'git-gutter-fr:deleted 'bottom
      "X......."
      "XX......"
      "XXX....."
      "XXXX...."
      "XXXXX..."
      "XXXXXX.."
      "XXXXXXX."
      "XXXXXXXX")

    (set-face-foreground 'git-gutter-fr:deleted "red")
    (set-face-background 'git-gutter-fr:deleted "transparent")
    (set-face-background 'git-gutter-fr:added "#98be65")
    (fringe-helper-define 'git-gutter-fr:added nil "")
    (set-face-background 'git-gutter-fr:modified "#d19a66")
    (fringe-helper-define 'git-gutter-fr:modified nil ""))

  (defhydra git-gutter-hydra ()
    "git-gutter"
    ("j" #'git-gutter:next-hunk "Next hunk" :column "Navigation")
    ("k" #'git-gutter:previous-hunk "Previous hunk")
    ("p" #'git-gutter:popup-hunk "Popup hunk")
    ("m" #'git-gutter:mark-hunk "Mark hunk")
    ("%" #'git-gutter:end-of-hunk "End of hunk")
    ("s" #'git-gutter:statistic "Statistic" :column "Operations")
    ("S" #'git-gutter:stage-hunk "Stage hunk")
    ("r" #'git-gutter:revert-hunk "Revert hunk")
    ("q" (message "Abort") "Quit" :exit t))
  (leader-def "h g" #'git-gutter-hydra/body)
#+end_src
* Text editing
** TODO multiple-cursors
Add it and make it compatible with Evil

#+begin_src emacs-lisp
  (leaf multiple-cursors
    :straight t
    :require t)
#+end_src
** Olivetti
#+begin_src emacs-lisp
  (leaf olivetti
    :straight t
    :require t
    :setq-default ((olivetti-body-width . 0.8)))
#+end_src
** avy
#+begin_src emacs-lisp
  (leaf avy
    :straight t
    :require t
    :config
    (leader-def
      "a a" #'avy-goto-char-timer
      "a l" #'avy-goto-line
      "a r c" #'avy-copy-region
      "a r m" #'avy-move-region
      "a r k" #'avy-kill-region))
#+end_src
** ace-link
#+begin_src emacs-lisp
  (leaf ace-link
    :straight t
    :require t
    :config
    (leader-def "l" #'ace-link))
#+end_src
** move-text
#+begin_src emacs-lisp
  (leaf move-text
    :straight t
    :require t
    :config
    (move-text-default-bindings))
#+end_src
** TODO snippets
#+begin_src emacs-lisp
  (leaf yasnippet
    :straight t)
#+end_src
** Translating
#+begin_src emacs-lisp
  (leaf go-translate
    :straight t
    :require t
    :setq ((gts-translate-list quote
                               (("en" "de")
                                ("en" "cz")
                                ("de" "en")))))
  ;; TODO: use emacs state in gts buffers
  ;; TODO: use minibuffer selection for languages everytime
#+end_src
* Optimization
#+begin_src emacs-lisp
  (leaf esup
    :straight t)
#+end_src
* Web services
** Pastebins
Easy access to pastebins
#+begin_src emacs-lisp
  (leaf webpaste
    :straight t)
#+end_src
* Hydras
** Install
#+begin_src emacs-lisp
  (leaf hydra
    :straight t
    :require t)
#+end_src
** Scripts
No hydras yet
* Useful tools
** TODO Crux
#+begin_src emacs-lisp
  (leaf crux
    :straight t)
#+end_src
** Devdocs
#+begin_src emacs-lisp
  (leaf devdocs
    :straight t
    :config
    ;; TODO: Add support for ace-link
    ;; TODO: Add Evil navigation
    (evil-set-initial-state 'devdocs-mode 'emacs)

    (defun devdocs-browser ()
      (interactive)

      (if (eq major-mode 'devdocs-mode)
          (progn
            (devdocs-copy-url)
            (let ((url (pop kill-ring)))
              (browse-url url)
              (message "%s opened!" url)))
        (message "ERROR: You are not in devdocs mode"))))
#+end_src
** Playground
#+begin_src emacs-lisp
  ;; TODO: add a playground minor mode with various features like in smalltalk's playground

  (defvar playground-default-name "playground"
    "Name that will be used for a playground buffer, if no name is
  specified in the function call.")
  (defvar playground-default-separator ":"
    "Character(s) that will be used adding an index to a playground buffer name.")
  (defvar playground-reuse-playgrounds nil
    "Non-nil if playgrounds should reuse names of closed playgrouds, otherwise a counter of previously opened playgrounds will be used.")
  (defvar playground--count 0
    "Count of playgrounds that have already been opened.")

  (defun playground-uniquify-name (name &optional separator)
    (when (not separator)
      (setq separator playground-default-separator))
    (if playground-reuse-playgrounds
        (progn
          (let ((i 1)
                (buffer-name))
            (while (get-buffer (setq buffer-name (concat name separator (number-to-string i))))
              (setq i (1+ i)))
            buffer-name))
      (let ((buffer-name (concat name separator (number-to-string playground--count))))
        (if (get-buffer buffer-name)
            (playground-uniquify-name name (concat separator separator))
          (setq playground--count (1+ playground--count))
          buffer-name))))

  (defun playground (&optional name)
    (interactive)

    (when (not name)
      (setq name playground-default-name))
    (let* ((buffer-name (playground-uniquify-name name))
           (buffer (get-buffer-create buffer-name)))
      (with-current-buffer buffer (emacs-lisp-mode))
      (pop-to-buffer buffer)))
#+end_src
* Personal config
#+begin_src emacs-lisp
  (let ((personal-config (f-join user-emacs-directory "personal-config.el")))
    (when (f-exists? personal-config)
      (message "Personal config found! Loading")
      (load personal-config)))
#+end_src
* TODO Calc
** TODO Learn how to use it
* Emenu
My own dmenu-like function
** Requirements
We need mini-frame because it provides child-frame minibuffer
functionality.
#+begin_src emacs-lisp
  (straight-use-package 'mini-frame)
#+end_src
** Source
#+begin_src emacs-lisp
  (defvar emenu-frame-params
    '((top . 0.3)
      (width . 0.5)
      (left . 0.8))
    "Parameters used for minibuffer frame.")

  (defmacro emenu (&rest body)
    "Run body with anything in minibuffer being in a frame centered on the screen."

    ;; TODO: Autofocus
    `(let ((mini-frame-status (if (eq mini-frame-mode nil) 0 1))
           (inhibit-quit t)
           (selectrum-max-window-height 25)
           (mini-frame-standalone t)
           (mini-frame-show-parameters emenu-frame-params))
       (mini-frame-mode 1)

       (unwind-protect
           (progn
             ,@body)
         (mini-frame-mode mini-frame-status))))
#+end_src
** Examples
#+begin_src emacs-lisp :tangle no :results value silent
  (emenu
   (let (operation value)
     (setq operation (completing-read "Operation: " '(("Uppercase") ("Lowercase")) nil t))

     (setq value (with-temp-buffer
                   (insert (read-string "Enter a string to convert: "))
                   (cond
                    ((string= operation "Uppercase") (upcase-region 1 (point-max)))
                    ((string= operation "Lowercase") (downcase-region 1 (point-max))))
                   (buffer-string)))
     (kill-new value)
     (message "%s" value)))
#+end_src
* Repeat mode
#+begin_src emacs-lisp
  (leaf repeat
    :require t
    :config
    (repeat-mode))
#+end_src
* REPL tools
#+begin_src emacs-lisp
  (defun nuke ()
    (interactive)

    (let ((inhibit-read-only t))
      (setf (buffer-string) "")))
#+end_src
** Lisp
*** Cider-like defun fringe
When defun is up-to-date, show green in fringe.
* TODO Screenshot
This doesn't load properly.
#+begin_src emacs-lisp :tangle no
  (leaf screenshot
    :straight (screenshot :type git :host github :repo "tecosaur/screenshot")
    :require t)
#+end_src
* TODO Spotify
Add some way to use spotify.
